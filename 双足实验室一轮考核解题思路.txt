第一题
根据哥德巴赫猜想：任何一个大于2的偶数总能表示为两个素数之和，那么对于
任何一个偶数a，问题归结为
case 1:寻找素数i和a-i,，i可以从数字2开始往后循环找，这里可以写一个函数 
prime（），判断i及a-i是否为素数，找到后打印即可。
接下来是a为奇数，又根据哥德巴赫猜想，知道任何一个大于5的奇数都可写成三个质数
之和。那么问题归结为
case 2:将奇数a分解为3+（a-3），其中a-3为大于2的偶数，变为case 1；
case 3：将最后的数字5=2+3归到case 1即可；

第二题
由于m和n是随机数，可以用rand（）生成，然后用malloc动态分配内存，生成二维
矩阵，每个元素同样可用rand（）初始化，这样便生成了原矩阵；
由于矩阵元素要移动，可以再构建一个矩阵和一个数组，先将矩阵内所有元素按照题目顺时针
要求存到数组val里，再通过赋值调整数组里元素的顺序，使得val中存取的数恰好为矩阵移动
一格后按顺时针读取的数，接着便可按顺时针将数组val里的数依次赋给矩阵c，打印即可。
注：矩阵元素的顺时针螺旋移动可以看成若干轮移动，每轮移动
可分解为4个循环，分别控制上下左右四条边上元素的移动，需要注意边界条件的判断，循环终止
的条件。

第三题
可以写两个函数，一个计算最小步数，一个打印字符。
由于整体过程太过复杂，不妨采用函数递归方法，根据n是否可整除2分为两种情况，如
果可以整除，那么一直除2直到为1即可。如果不能整除2，则接下来选项有两个，+1 or
 -1，这时需要分别计算出
两种情况n+1与n-1（都为偶数）变为1的最小步数，此时成了函数递归。下面是终止条
件的确定，考虑到最后都递归到了1，此时过程结束，步数+0，可写为return 0；最后
打印即可。
打印字符函数与计算最小步数函数类似，增加了打印的步骤，不过由于某些递归过程不
需要打印字符，所以添加了一个变量g，根据g的状态确定是否要打印字符，为1就打印。

第四题
case 1:如果机子比人多，那么先将前m个人放到前m台机器里,每过一秒钟，占有机器
的每个人手里快递件-1，如果此时快递件==0，人离开，空出的位置由后面的人接上，
人数-1。当一个机子前开始没人排了，用变量en计数，当en==m（总共的机子数），
工程结束，输出累计的时间。
case 2：每人都有一台机子，那么问题转换成求所有人手里快递件的最大值，用数组
存储比较计算即可。

第五题
先创建个变量n为接下来的数据，循环将字符串前的数字和字符串内容分别放到
两个数组里，用count数组记录每条数据的有效长度，用num记录有效的数据的
条数。接着根据题目要求，将收集的数字转换成字符存放到一个字符数组里，
然后将每条数据的有效部分经过一个tranfer（）函数加密，紧接着将每条存放
数据的字符数组通过strcat（）函数连接到前面已存放编号等数字的字符数组里，
最后打印这个数组即可。
